0.  BMP: max 16.777.216 (24 bit)
    JPG: max 16.777.216 (24 bit)
    PNG: max 16.777.216 (24 bit)
    GIF: max 256 (8 bit) (chosen in a 24bit field)

1.  GIF

2.  A lossy encoding imply the definitive loss of information, besides a lossless codec can avoid any information lost, even after compression.
    
3.  JPG

4.  The address of the file in the disk is deleted from the index table, AKA File Allocation Table, but the file itself is leaved untouched in the Data Region of the FAT file system.

5.  Randomly changing the file in Data Region, or changing them all to either 0 or 1 (as in zero-fill).

6.  This header file contains the definition for various data type that has to satisfy specific width requirements, plus macros about their limits and 'function-like macros' that allow you to expant some values.

7.  To use a fixed, pre-determined space. Working with row (binary) file, where the specifications are written by others, this is a necessary 'precaution'. 

8.  According to the offset table in the specification,  
    BYTE: 1 byte
    DWORD: 4 bytes
    LONG: 4 bytes
    WORD: 2 bytes

9.  The first two byte compose the bfType variable, expressed as BM (ASCII) or [0xff, 0xd8] in hexadecimal. Togheter with the third byte, they compose the signature of the BMP file. 

10. bfType: the size of the bitmap file, expressed in bytes;
    biType: the number of bytes required by the structure, does not include the color table.

11. A negative biHeight indicates that the bitmap is a top-down DIB (device-independent bitmaps) that is simply the direction (top-left corner to the bottom-right corner) in which the image is written as an ordinated series of pixel. According to the msdn.microsoft, a negative value alse express that the compression must be 'rgb' or 'bitfiels', that are actually non-compressed; positive values seems to allow compression.

12. biBitCount express the number of bits-per-pixel, that determines also the number of usable color. The range is [0, 32], with different usable set of colors.

13. As an alert when the requested output file cannot be created. This problem can be generated by a full disk, a lack of permission etc. 

14. fread include specifically 2 parameters, size and nmemb. the first express how many bytes must be readed, the second how many chunk of data must be readed at once. If Stack Overflow has never teach anything, the actual implementation of the function should require the same computational effort, in both the case that I require 512 chunks of 1 byte or 1 chunk of 512 bytes. However, there is a difference in how the various error will be handled. In particular, if I require a bunch of bytes that are not fully present in the opened file, the first implementation is going to respond the number of byte readed, the latter instead will respond 0 and through away the last not-long-enough chunk of bytes. Given the implementation of copy.c, in which there is no special error handling, the only explanation I can come with is that we know for shure that the enique file we elaborate is a precise multiple of 512 bytes, and we don't want to handle any other case-specific errors. In this case, knowing that the camera store 512 bytes per write, is makes logically more sense to read them as 1 block of 512 bytes. 

15. The BMP store the line of pixel as a multiple of 4 bytes, besides the line can be any descrete number of pixels. The padding value bridge these values, by expressing the "unused" part of the multiple of 4 that the line is currently not using. In this case, the line is using 3 pixels, and the nearest (and greater) multiple of 4 is actually 4. 4 - 3 = 1 pixel used in the padding.

16. Fseek "moves the file pointer to a specific location". In fact, fread &co. use a file as a long string of data, readind bytes in a consequential fashion, where the position in which start reading is determined by the last I/O operation. I can override this default behavior by manually reposition the cursor at the begin of the interesting chunk of data. To do this, I call "fseek" by telling him which is the file (as a pointer), the offset (the dimension of the reposition, how many bytes before or after), and the origin (the initial position). As origin, fseek accept 1 in 3 parameters: SEEK_CUR, SEEK_END, SEEK_SET.

17. SEEK_CUR, in the fseek environment, express the current position of the file pointer. That is, when I call fseek with SEEK_CUR as origin, I'm telling him to move the cursor from the current position to somewhere else. As an example, the correct current position can be asked to ftell, to avoid any potential error. Alternatives can be SEED_END, the end of file, or SEEK_SET, the beginning of file.

18. Rick Astley
